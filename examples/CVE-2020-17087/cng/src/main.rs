
use std::io::{self, Read};

use std::ffi::CString;
use std::ptr::null_mut;

use winapi::um::fileapi::{CreateFileA, OPEN_EXISTING};
use winapi::um::winnt::{GENERIC_READ, GENERIC_WRITE, HANDLE};
use winapi::um::ioapiset::DeviceIoControl;
use winapi::um::handleapi::{CloseHandle, INVALID_HANDLE_VALUE};
// use winapi::um::errhandlingapi::GetLastError;

use clap::{Clap, crate_version};

use color_eyre::eyre::{Result, WrapErr};


#[derive(Clap, Debug)]
#[clap(version=crate_version!(), author="Damien Aumaitre")]
pub struct Cli {

    #[clap(long="data", parse(from_os_str))]
    pub data: Option<std::path::PathBuf>,

    #[clap(long="size")]
    pub size: Option<usize>,

}


fn main() -> Result<()> {
    color_eyre::install()?;

    let args = Cli::parse();

    let device = CString::new("\\\\.\\GLOBALROOT\\Device\\Cng").wrap_err("Failed to create cstring")?;
    let h_cng = validate_handle(unsafe { 
        CreateFileA(device.as_ptr(),
            GENERIC_READ | GENERIC_WRITE,
            0,
            null_mut(),
            OPEN_EXISTING,
            0,
            null_mut())
    }).wrap_err("Failed to open handle to \\\\Device\\Cng")?;

    println!("opened \\Device\\Cng, handle: {:?}", h_cng);

    let ioctl = 0x390400;
    let mut output = vec![0u8; 8];
    let mut bytes = 0;

    let mut input = match args.data {
        Some(path) => {
            let mut file = std::fs::File::open(path)?;
            let mut input = Vec::new();
            file.read_to_end(&mut input)?;
            input
        }
        None => {
            let size = args.size.unwrap_or(8);
            vec![0u8; size]
        }
    };

    match args.size {
        Some(size) => {
            input.resize(size, 0);
        }
        None => ()
    }

    println!("will send {:x} bytes to device", input.len());

    let status = cvt(unsafe {
        DeviceIoControl(h_cng,
            ioctl,
            input.as_mut_ptr() as *mut _,
            input.len() as u32,
            output.as_mut_ptr() as *mut _,
            output.len() as u32,
            &mut bytes,
            null_mut())
    });

    println!("sent ioctl, result is {:x}", bytes);
    println!("output: {:#x?}", &output);

    match status {
        Ok(_) => {
        }
        Err(err) => {
            println!("got error: {:?}", err);

        }
    }

    unsafe {
        CloseHandle(h_cng);
    }

    Ok(())
}

fn cvt(i: i32) -> io::Result<i32> {
    if i == 0 {
        Err(io::Error::last_os_error())
    } else {
        Ok(i)
    }
}

fn validate_handle(handle: HANDLE) -> io::Result<HANDLE> {
    if handle == INVALID_HANDLE_VALUE {
        Err(io::Error::new(io::ErrorKind::Other, "Handle is invalid"))
    } else {
        Ok(handle)
    }
}
// int main() {
//   HANDLE hCng = CreateFileA("\\\\.\\GLOBALROOT\\Device\\Cng",
//     GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);

//   if (hCng == NULL) {
//     printf("[-] Failed to open \\Device\\Cng: %u\n", GetLastError());
//     return 1;
//   }

//   printf("[+] \\Device\\Cng opened, handle: %p\n", hCng);

//   BOOL Status = DeviceIoControl(
//     hCng,
//     0x390400,
//     IoctlData,
//     IoctlSize,
//     &OutputBuffer,
//     sizeof(OutputBuffer),
//     &BytesReturned,
//     NULL
//   );

//   printf("[+] Ioctl sent, Status: %d, OutputBuffer: %zx, BytesReturned: %lx\n", Status, OutputBuffer, BytesReturned);

//   HeapFree(GetProcessHeap(), 0, IoctlData);
//   CloseHandle(hCng);

