
# Rewind vs world: episode 1 CVE-2020-17087

## Motivation

I always enjoy doing kernel vulnerability research specially on Windows kernel. The process
always involve a mix of static and dynamic analysis. Doing dynamic analysis can quickly become
tedious. The cycle debug / crash / reboot / reset all breakpoints is slow and painful. When you
want to do some fuzzing, it often requires you to setup one or several virtual machines plus a
kernel debugger and craft some highly reliable scripts to handle crash detection...

Doing snapshot with virtual machines helps but it's still slow as F...

During 2018 Microsoft introduced a new set of API named Windows Hypervisor Platform (WHVP). These
API allow to setup a partition (VM in hyper-v lingua) with some virtual processors and to have a
control on the VM exits occurring in the virtual machine. It's almost like having your own
vm-exit handler in userland. Quite handy to do useful things

FIXME: link vers simpleator and applepie
https://github.com/ionescu007/Simpleator
https://github.com/gamozolabs/applepie


So I started to play with WHVP and made a first PoC allowing me to execute
in a Hyper-V partition some shellcode. It was written in Python and quite slow. This first PoC
evolved quite quickly to some kind of snapshot-based tracer. I wanted to have something to
bootstrap the virtual CPU and quite easy to setup. So since I was already using a kernel debugger
to play with my target, I decided to use a dump made with WinDbg as my snapshot. With that I just
need to setup a partition with a virtual cpu. The virtual cpu context is set with the context
taken from the dump. Whenever the virtual cpu needs a physical page I use the ones from the dump.

With this I was able to fork the state of the dump into a partition and then resume execution. 
It allowed me to easily trace the execution of my target function. By modifying the arguments and
reverting the memory state of the partition it was also really easy to fuzz the target.

To sum up this tool is a PoC for a snapshot-based coverage-guided fuzzer targeting Windows kernel components.

The idea is to clone the state of a running kernel (cpu and memory) into an Hyper-V partition to
execute a specific function. A targeted small virtual machine is obtained by mapping the
requested code and data needed to run this function. The state is read from a snapshot obtained
from a kernel debugger. This small VM is then used to perform various tasks useful for a
vulnerability researcher like getting an execution trace for the targeted function or fuzzing
user-controlled inputs.

It leverages WHVP (Windows Hypervisor Platform) API to provide access to a Hyper-V partition. See
https://docs.microsoft.com/en-us/virtualization/api/hypervisor-platform/hypervisor-platform for
more details.

The work was presented at a French conference last year.
https://github.com/quarkslab/whvp
https://www.sstic.org/2020/presentation/fuzz_and_profit_with_whvp/

The tool implement 2 possibilities to do coverage tracing. The first one leverages the classical TF (Trap Flag) to have INT1 interruptions on every instruction. 
It requires to modify the target and it's slow. I would have preferred to use MONITOR trap flag. But WHVP doesn't offer this possibility.

http://hypervsir.blogspot.com/2014/11/monitor-trap-flag-mtf-usage-in-ept.html

In order to have proper performances (required for fuzzing), I decided to reduce the precision of the coverage and add a mode when you know when an instruction is executed for the first time (but not for the next executions)
To do that I patch the pages fetched from the snapshot with 0xcc bytes (only for executable pages). When the cpu will execute these patched instructions the hypervisor will trap the exception and rewrite the instructions with the original code.
It's like having a software breakpoint set on every instruction. It works 95% of the time but in particular piece of code (ones with jump tables for example) it will fail because data will be replaced.
To overcome this one option would be to disassemble the code before mapping it and only patch what is needed (maybe next time).

FIXME: need an image to illustrate that (use cng vuln ?)

During my experiment I encountered several limitations when using WHVP. It's slow, like really slow. Virtual box have some useful comments.

FIxME: vbox
https://www.virtualbox.org/browser/vbox/trunk/src/VBox/VMM/VMMR3/NEMR3Native-win.cpp
The comments at the end of this file are really interesting.

So to have proper performance you really need to limit VM exits and it's incompatible if you want to use Hyper-V as a tracing hypervisor (since it requires a lot of VM exits).

During the same time I started to use bochs (specially the instrumentation part) to check if the traces obtained by the tool were correct. At this time Bochs was some kind of oracle to see if I had divergent traces.

https://bochs.sourceforge.io/cgi-bin/lxr/source/instrument/instrumentation.txt

And (drums) bochs is faster than WHVP and you have some basic instrumentations for memory accesses and immediates values extract
FIXME: show some benchmark

I decided to add bochs as another backend to the tool. And rewind is born :)
So whvp was not a proper name anymore
A lot of refactor also happened I also remove the python part

# Basic design

Explain how everything works

# 

I decided to check if the tool was able to find real world vulnerabilities. The main use case of rewind is to be able to trace or fuzz a function encountered during kernel driver assessment.
So I need a vulnerability in a driver (in an ioctl would be perfect).


https://bugs.chromium.org/p/project-zero/issues/detail?id=2104

The Windows Kernel Cryptography Driver (cng.sys) exposes a \Device\CNG device to user-mode programs and supports a variety of IOCTLs with non-trivial input structures. It constitutes a locally accessible attack surface that can be exploited for privilege escalation (such as sandbox escape).

We have identified a vulnerability in the processing of IOCTL 0x390400, reachable through the following series of calls:

1. cng!CngDispatch
2. cng!CngDeviceControl
3. cng!ConfigIoHandler_Safeguarded
4. cng!ConfigFunctionIoHandler
5. cng!_ConfigurationFunctionIoHandler
6. cng!BCryptSetContextFunctionProperty
7. cng!CfgAdtReportFunctionPropertyOperation
8. cng!CfgAdtpFormatPropertyBlock

The bug resides in the cng!CfgAdtpFormatPropertyBlock function and is caused by a 16-bit integer truncation issue. It is best explained with a C-like pseudo code of the function:

[rajouter screenshot ida]

CfgAdtpFormatPropertyBlock

![](atdp.png)

https://attackerkb.com/topics/y8mmBHc710/cve-2020-17087-windows-kernel-local-privilege-escalation-0day

An error exists within cng!CfgAdtpFormatPropertyBlock where buffer is allocated from a value that is truncated to be 16-bits. The function then goes on and performs a binary to ASCII hex conversion, writing the ASCII hex characters to this buffer. While performing the conversion, the original buffer’s correct length is used causing the write to continue out of bounds.

The vector for this vulnerability is local. A malicious attacker would first have to have code execution on the target system from any context including that of a sandboxed application. From there they would open a handle to \\.\GLOBALROOT\Device\Cng before issuing the 0x390400 IOCTL with a crafted input buffer. The crafted input buffer contains a size parameter as one of the fields that when set to 0x2aab or greater will trigger the overflow.

Exploitation of this bug won’t be easy due to it being a heap based memory corruption within the kernel’s NonPagedPool. The attacker has partial control over the size of the allocation as constrained by ((size * 6) & 0xffff).

In this part, explain motivation, why do kernel fuzzing
why do snapshot based fuzzing

Explain rewind genesis
https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptsetcontextfunctionproperty
https://bugs.chromium.org/p/project-zero/issues/detail?id=2104
https://attackerkb.com/topics/y8mmBHc710/cve-2020-17087-windows-kernel-local-privilege-escalation-0day

# 

In this part explain the choosen vulnerability
explain the setup to reproduce it

```rust
let device = CString::new("\\\\.\\GLOBALROOT\\Device\\Cng").wrap_err("Failed to create cstring")?;
let h_cng = validate_handle(unsafe { 
    CreateFileA(device.as_ptr(),
        GENERIC_READ | GENERIC_WRITE,
        0,
        null_mut(),
        OPEN_EXISTING,
        0,
        null_mut())
}).wrap_err("Failed to open handle to \\\\Device\\Cng")?;

println!("opened \\Device\\Cng, handle: {:?}", h_cng);

let ioctl = 0x390400;

[snip]

println!("will send {:x} bytes to device", input.len());

let status = cvt(unsafe {
    DeviceIoControl(h_cng,
        ioctl,
        input.as_mut_ptr() as *mut _,
        input.len() as u32,
        output.as_mut_ptr() as *mut _,
        output.len() as u32,
        &mut bytes,
        null_mut())
});

println!("sent ioctl, result is {:x}", bytes);
println!("output: {:#x?}", &output);
```

```
Loading Dump File [C:\Projets\Rewind\examples\snapshots\19041.1.amd64fre.vb_release.191206-1406\cng\ConfigIoHandler_Safeguarded\mem.dmp]
Kernel Bitmap Dump File: Active memory is available


************* Path validation summary **************
Response                         Time (ms)     Location
Deferred                                       srv*
Symbol search path is: srv*
Executable search path is: 
Windows 10 Kernel Version 19041 UP Free x64
Product: WinNt, suite: TerminalServer SingleUserTS
Edition build lab: 19041.1.amd64fre.vb_release.191206-1406
Machine Name:
Kernel base = 0xfffff802`48600000 PsLoadedModuleList = 0xfffff802`4922a310
Debug session time: Fri Nov 27 17:49:59.609 2020 (UTC + 2:00)
System Uptime: 0 days 0:03:39.807
Loading Kernel Symbols
...............................................................
.............Page b0b1d not present in the dump file. Type ".hh dbgerr004" for details
...................................................
...................................
Loading User Symbols
............
Loading unloaded module list
......
For analysis of this file, run !analyze -v
cng!ConfigIoHandler_Safeguarded:
fffff802`4b436c3c 4c8bdc          mov     r11,rsp
```

```
kd> vertarget
Windows 10 Kernel Version 19041 UP Free x64
Product: WinNt, suite: TerminalServer SingleUserTS
Edition build lab: 19041.1.amd64fre.vb_release.191206-1406
Machine Name:
Kernel base = 0xfffff804`80400000 PsLoadedModuleList = 0xfffff804`8102a310
Debug session time: Tue Dec  1 16:09:45.766 2020 (UTC + 2:00)
System Uptime: 0 days 0:03:43.461
```

```
Loading Dump File [C:\Users\erynian\Documents\Quarkslab\Projets\Rewind\examples\snapshots\19041.1.amd64fre.vb_release.191206-1406\cng\_ConfigurationFunctionIoHandler\mem.dmp]
Kernel Bitmap Dump File: Active memory is available


************* Path validation summary **************
Response                         Time (ms)     Location
Deferred                                       srv*
Symbol search path is: srv*
Executable search path is: 
Windows 10 Kernel Version 19041 UP Free x64
Product: WinNt, suite: TerminalServer SingleUserTS
Edition build lab: 19041.1.amd64fre.vb_release.191206-1406
Machine Name:
Kernel base = 0xfffff804`80400000 PsLoadedModuleList = 0xfffff804`8102a310
Debug session time: Tue Dec  1 16:09:45.766 2020 (UTC + 2:00)
System Uptime: 0 days 0:03:43.461
Loading Kernel Symbols
...............................................................
................................................................
...................................
Loading User Symbols
............
Loading unloaded module list
..........
For analysis of this file, run !analyze -v
cng!_ConfigurationFunctionIoHandler:
fffff804`83037f54 488bc4          mov     rax,rsp
```

```json
{
  "gdtr": 18446735287495565232,
  "gdtl": 87,
  "idtr": 18446735287495553024,
  "idtl": 4095,
  "cr0": 2147811377,
  "cr3": 3023859714,
  "cr4": 3606136,
  "cr8": 15,
  "efer": 3329,
  "cs": {
    "selector": 16,
    "base": 0,
    "limit": 0,
    "flags": 8859
  },
  "ss": {
    "selector": 24,
    "base": 0,
    "limit": 0,
    "flags": 1171
  },
  "ds": {
    "selector": 43,
    "base": 0,
    "limit": 4294967295,
    "flags": 3315
  },
  "es": {
    "selector": 43,
    "base": 0,
    "limit": 4294967295,
    "flags": 3315
  },
  "fs": {
    "selector": 83,
    "base": 0,
    "limit": 15360,
    "flags": 1267
  },
  "gs": {
    "selector": 43,
    "base": 0,
    "limit": 4294967295,
    "flags": 3315
  },
  "fs_base": 0,
  "gs_base": 18446735287357579264,
  "kernel_gs_base": 679092035584,
  "sysenter_cs": 0,
  "sysenter_esp": 0,
  "sysenter_eip": 0,
  "star": 9851692904349696,
  "lstar": 18446735287431278976,
  "cstar": 18446735287431278144,
  "apic_base": 4276095232,
  "rax": 898,
  "rbx": 0,
  "rcx": 18446678112947511296,
  "rdx": 15019,
  "rsi": 18446678112947511296,
  "rdi": 18446631973432879112,
  "r8": 18446678112947511296,
  "r9": 18446631973432879112,
  "r10": 18446735287469160048,
  "r11": 0,
  "r12": 3221225659,
  "r13": 0,
  "r14": 18446678112946964800,
  "r15": 3736576,
  "rbp": 4,
  "rsp": 18446631973432878968,
  "rip": 18446735287469173820,
  "rflags": 262726
}
```

```json
{
  "return_address": 18446735287469171167,
  "excluded_addresses": {
    "nt!KeBugCheck": 18446735287424861568,
    "nt!KeBugCheck2": 18446735287426025024,
    "nt!KeBugCheckEx": 18446735287424861600
  }
}
```

![](input_hexdump.png)

explain how to obtain a snapshot
explain what need to be changed in order to reproduce the vulnerability
explain you need to adjust parameters 
explain the root cause

# 

in this part present how to reproduce the vuln with rewind
run tracer with bochs first
explain first crash
explain why we need to modify the tracing
explain how to do that with rewind
run the input until it's successful
explain why no bluescreen ?
explain how to do a dummy sanitizer
explain that we could have use driver verifier too but don't want to modify the target

```
rewind.exe-trace-run
Damien Aumaitre

USAGE:
    rewind.exe trace run [FLAGS] [OPTIONS] --snapshot <snapshot>

FLAGS:
    -h, --help                 Prints help information
        --last                 Show last executed instructions
        --save-context
        --show-coverage        Show coverage after execution
        --show-instructions    Show executed instructions after execution
    -v, --verbose              Set the level of verbosity
    -V, --version              Prints version information

OPTIONS:
        --backend <backend>             [default: bochs] [possible values: whvp, bochs]
        --coverage <coverage>           [default: no] [possible values: no, instrs, hit]
        --data <data>                   Input data
        --filter <filter>               Show only instructions matching pattern
        --input <input>                 JSON file describing input
        --count <instructions-count>    Number of instructions to display
        --limit <limit>                 [default: 0]
        --max-time <max-time>           [default: 0]
        --save-input <save-input>       Save input to file
        --skip <skip-instructions>      Number of instructions to skip
        --snapshot <snapshot>           Snapshot path
        --store <store>                 Symbol store
        --save-trace <trace>            Save trace to file
```


```
❯ rewind trace run --backend bochs --snapshot .\snapshots\19041.1.amd64fre.vb_release.191206-1406\cng\ConfigIoHandler_Safeguarded\
:: Running tracer
==> loading snapshot
==> will use bochs backend
==> setting tracer initial state
rax=0000000000000382 rbx=0000000000000000 rcx=ffffc4025035a000
rdx=0000000000003aab rsi=ffffc4025035a000 rdi=ffff9a0b9ed46808
rip=fffff8024b436c3c rsp=ffff9a0b9ed46778 rbp=0000000000000004
 r8=ffffc4025035a000  r9=ffff9a0b9ed46808 r10=fffff8024b433670
r11=0000000000000000 r12=00000000c00000bb r13=0000000000000000
r14=ffffc402502d4940 r15=0000000000390400
cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b  rflags=40246
==> running tracer
==> executed 10747 instruction(s) in 56.9244ms (Success)
==> seen 3350 unique address(es)
==> mapped 129 page(s) (528.38 kB)
==> 40 page(s) were modified
```

```
❯ tree store
store
├── binaries
│   ├── cng.sys
│   │   ├── 2482C10CB7000
│   │   │   └── cng.sys
│   │   └── A7D172D6B7000
│   │       ├── cng.sys
│   ├── hal.dll
│   │   └── F8B4C72E9C000
│   │       └── hal.dll
│   └── ntoskrnl.exe
│       ├── 6105701FA71000
│       │   ├── ntoskrnl.exe
│       └── 90EE290B1046000
│           └── ntoskrnl.exe
└── symbols
    ├── cng.pdb
    │   ├── 48859d06bf92471e702abbc952f1c8ec1
    │   │   └── cng.pdb
    │   └── 86b63eb98ed873ddcb7654ac95c8c3ed1
    │       └── cng.pdb
    ├── hal.pdb
    │   └── 807db9487e66a225f419f924f4f06eaf1
    │       └── hal.pdb
    └── ntkrnlmp.pdb
        ├── 20c711bbd4c21aa5c45bc774bc7e04721
        │   └── ntkrnlmp.pdb
        └── b16053724b46515388fdea9d0470d02e1
            └── ntkrnlmp.pdb

18 directories, 17 files
```

```
❯ rewind trace run --backend bochs --snapshot .\snapshots\19041.1.amd64fre.vb_release.191206-1406\cng\ConfigIoHandler_Safeguarded\ --show-coverage --store .\store\
:: Running tracer
==> loading snapshot
==> will use bochs backend
==> setting tracer initial state
rax=0000000000000382 rbx=0000000000000000 rcx=ffffc4025035a000
rdx=0000000000003aab rsi=ffffc4025035a000 rdi=ffff9a0b9ed46808
rip=fffff8024b436c3c rsp=ffff9a0b9ed46778 rbp=0000000000000004
 r8=ffffc4025035a000  r9=ffff9a0b9ed46808 r10=fffff8024b433670
r11=0000000000000000 r12=00000000c00000bb r13=0000000000000000
r14=ffffc402502d4940 r15=0000000000390400
cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b  rflags=40246
==> running tracer
==> executed 10747 instruction(s) in 10.1894ms (Success)
==> seen 3350 unique address(es)
==> mapped 129 page(s) (528.38 kB)
==> 40 page(s) were modified

:: Analysing trace
==> loading modules
==> parsing trace
==> displaying coverage
cng!AlgorithmCheck: 8 instructions
cng!BCryptAlloc: 16 instructions
cng!BCryptFree: 17 instructions
cng!CngDeviceControl: 1 instructions
cng!ConfigIoHandler_Safeguarded: 70 instructions
cng!IoUnpack_SG_ParamBlock_Header: 17 instructions
cng!WinErrorToNtStatus: 15 instructions
cng!memmove: 51 instructions
ntkrnlmp!ExAllocateHeapPool: 219 instructions
ntkrnlmp!ExAllocatePoolWithTag: 37 instructions
ntkrnlmp!ExFreeHeapPool: 265 instructions
ntkrnlmp!ExFreePoolWithTag: 4 instructions
ntkrnlmp!ExpAcquireSpinLockExclusive: 26 instructions
ntkrnlmp!ExpAddTagForBigPages: 109 instructions
ntkrnlmp!ExpTryAcquireSpinLockShared: 8 instructions
ntkrnlmp!MiDeterminePoolType: 14 instructions
ntkrnlmp!RtlRbInsertNodeEx: 237 instructions
ntkrnlmp!RtlRbRemoveNode: 279 instructions
ntkrnlmp!RtlpHpAcquireQueuedLockExclusive: 25 instructions
ntkrnlmp!RtlpHpReleaseQueuedLockExclusive: 29 instructions
ntkrnlmp!RtlpHpSegDescriptorValidate: 34 instructions
ntkrnlmp!RtlpHpSegLfhVsCommit: 62 instructions
ntkrnlmp!RtlpHpSegLfhVsDecommit: 51 instructions
ntkrnlmp!RtlpHpSegPageRangeCommit: 130 instructions
ntkrnlmp!RtlpHpVsChunkAlignSplit: 58 instructions
ntkrnlmp!RtlpHpVsChunkCoalesce: 203 instructions
ntkrnlmp!RtlpHpVsChunkComputeCost: 56 instructions
ntkrnlmp!RtlpHpVsChunkSplit: 568 instructions
ntkrnlmp!RtlpHpVsContextAllocateInternal: 179 instructions
ntkrnlmp!RtlpHpVsContextFree: 306 instructions
ntkrnlmp!RtlpHpVsFreeChunkInsert: 123 instructions
ntkrnlmp!RtlpHpVsFreeChunkRemove: 28 instructions
ntkrnlmp!RtlpHpVsSubsegmentCommitPages: 94 instructions
ntkrnlmp!_guard_dispatch_icall: 11 instructions
```

A lot of things seems moved. Input is empty and 40 pages were modified. Snapshot restoration will be slow.
We need to go deeper.


![](ida_entrypoint.png)

```
❯ rewind trace run --backend bochs --snapshot .\snapshots\19041.1.amd64fre.vb_release.191206-1406\cng\_ConfigurationFunctionIoHandler\ --show-coverage --store .\store\
:: Running tracer
==> loading snapshot
==> will use bochs backend
==> setting tracer initial state
rax=ffff8704058ae790 rbx=0000000000003aab rcx=0000000000010400
rdx=ffffaa0f0d4cb000 rsi=0000000000000008 rdi=0000000000003aab
rip=fffff80483037f54 rsp=ffff8704058ae6c8 rbp=0000000000000008
 r8=0000000000003aab  r9=ffffaa0f1f7ee000 r10=0000000000000000
r11=ffffaa0f0d4cb008 r12=ffffaa0f0d4cb000 r13=ffff8704058ae808
r14=ffffaa0f1f7ee000 r15=ffffaa0f1f8f1000
cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b  rflags=40246
==> running tracer
==> executed 509 instruction(s) in 3.8129ms (Success)
==> seen 360 unique address(es)
==> mapped 18 page(s) (73.73 kB)
==> 3 page(s) were modified

:: Analysing trace
==> loading modules
==> parsing trace
==> displaying coverage
cng!AlgorithmCheck: 31 instructions
cng!IoUnpack_SG_Configuration_ParamBlock: 117 instructions
cng!IoUnpack_SG_SzString: 89 instructions
cng!SzString_CchLength: 38 instructions
cng!WinErrorToNtStatus: 18 instructions
cng!_ConfigFunctionIoHandler: 1 instructions
cng!_ConfigurationFunctionIoHandler: 66 instructions
```

```
❯ rewind trace run --backend whvp --coverage instrs --snapshot .\snapshots\19041.1.amd64fre.vb_release.191206-1406\cng\_ConfigurationFunctionIoHandler\
:: Running tracer
==> loading snapshot
==> will use whvp backend
==> setting tracer initial state
rax=ffff8704058ae790 rbx=0000000000003aab rcx=0000000000010400
rdx=ffffaa0f0d4cb000 rsi=0000000000000008 rdi=0000000000003aab
rip=fffff80483037f54 rsp=ffff8704058ae6c8 rbp=0000000000000008
 r8=0000000000003aab  r9=ffffaa0f1f7ee000 r10=0000000000000000
r11=ffffaa0f0d4cb008 r12=ffffaa0f0d4cb000 r13=ffff8704058ae808
r14=ffffaa0f1f7ee000 r15=ffffaa0f1f8f1000
cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b  rflags=40246
==> running tracer
==> executed 509 instruction(s) in 13.0445ms (Success)
==> seen 359 unique address(es)
==> mapped 17 page(s) (69.63 kB)
==> 12 page(s) were modified
```

When I told you that whvp was slower. Notice that the number of pages modified are different and the number of unique addresses too

FIXME: patch dump ?

```
❯ rewind trace run --backend bochs --coverage instrs --snapshot .\snapshots\19041.1.amd64fre.vb_release.191206-1406\cng\_ConfigurationFunctionIoHandler\ --input .\input.json --data .\46473e281d56fad5.bin
:: Running tracer
==> loading snapshot
==> will use bochs backend
==> setting tracer initial state
rax=ffff8704058ae790 rbx=0000000000003aab rcx=0000000000010400
rdx=ffffaa0f0d4cb000 rsi=0000000000000008 rdi=0000000000003aab
rip=fffff80483037f54 rsp=ffff8704058ae6c8 rbp=0000000000000008
 r8=0000000000003aab  r9=ffffaa0f1f7ee000 r10=0000000000000000
r11=ffffaa0f0d4cb008 r12=ffffaa0f0d4cb000 r13=ffff8704058ae808
r14=ffffaa0f1f7ee000 r15=ffffaa0f1f8f1000
cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b  rflags=40246
==> replaying input ".\\46473e281d56fad5.bin"
==> writing input to ffffaa0f0d4cb000 (3aab)
==> running tracer
==> executed 2332414 instruction(s) in 1.0672337s (ForbiddenAddress("found excluded address nt!KeBugCheckEx"))
==> seen 23876 unique address(es)
==> mapped 988 page(s) (4.05 MB)
==> 252 page(s) were modified
```

It's strange we shouldn't encounter a bugcheck since the bug is a heap overflow and we don't use the corrupted memory.

```
❯ rewind trace run --backend bochs --coverage instrs --snapshot .\snapshots\19041.1.amd64fre.vb_release.191206-1406\cng\_ConfigurationFunctionIoHandler\ --input .\input.json --data .\46473e281d56fad5.bin --show-instructions --count 10 --show-coverage --store .\store\
:: Running tracer
==> loading snapshot
==> will use bochs backend
==> setting tracer initial state
rax=ffff8704058ae790 rbx=0000000000003aab rcx=0000000000010400
rdx=ffffaa0f0d4cb000 rsi=0000000000000008 rdi=0000000000003aab
rip=fffff80483037f54 rsp=ffff8704058ae6c8 rbp=0000000000000008
 r8=0000000000003aab  r9=ffffaa0f1f7ee000 r10=0000000000000000
r11=ffffaa0f0d4cb008 r12=ffffaa0f0d4cb000 r13=ffff8704058ae808
r14=ffffaa0f1f7ee000 r15=ffffaa0f1f8f1000
cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b  rflags=40246
==> replaying input ".\\46473e281d56fad5.bin"
==> writing input to ffffaa0f0d4cb000 (3aab)
==> running tracer
==> executed 2332414 instruction(s) in 1.0928829s (ForbiddenAddress("found excluded address nt!KeBugCheckEx"))
==> seen 23876 unique address(es)
==> mapped 988 page(s) (4.05 MB)
==> 252 page(s) were modified

:: Analysing trace
==> loading modules
==> parsing trace
==> displaying coverage
cng!?StringCchPrintfW@@YAJPEAG_KPEBGZZ: 43 instructions
cng!AlgorithmCheck: 111 instructions
cng!BCryptAlloc: 16 instructions
cng!BCryptFree: 17 instructions
cng!BCryptSetContextFunctionProperty: 103 instructions
cng!CfgReg_Acquire: 50 instructions
cng!DataBlock_Alloc: 36 instructions
cng!DataBlock_Copy: 32 instructions
cng!DataBlock_Update: 60 instructions
cng!IoUnpack_SG_Buffer: 48 instructions
cng!IoUnpack_SG_Configuration_ParamBlock: 233 instructions
cng!IoUnpack_SG_ContextFunctionConfig: 42 instructions
cng!IoUnpack_SG_SzString: 97 instructions
cng!KeRegCloseKey: 26 instructions
cng!KeRegOpenKey: 54 instructions
cng!KeRegSetValue: 30 instructions
cng!SaveBinaryValue: 21 instructions
cng!SzString_CchLength: 38 instructions
cng!ValidateInterfaceId: 8 instructions
cng!ValidateTableId: 5 instructions
cng!VerifyRegistryAccess: 17 instructions
cng!WideString_Alloc: 44 instructions
cng!WideString_AllocCopy: 53 instructions
cng!WideString_Compare: 42 instructions
cng!WideString_From_Numeric: 29 instructions
cng!WideString_Init_FromSzString: 27 instructions
cng!_CfgReg_OnSaveContextNode: 88 instructions
cng!_CfgReg_OnSaveFunctionNode: 104 instructions
cng!_CfgReg_OnSaveInterfaceNode: 83 instructions
cng!_CfgReg_OnSavePropertyNode: 20 instructions
cng!_CfgReg_OnSaveTableNode: 72 instructions
cng!_CfgReg_SaveRoot: 69 instructions
cng!_ConfigurationFunctionIoHandler: 74 instructions
cng!_FindOrAddFunctionPropertyCfg: 169 instructions
cng!_NewLocalMachineKeyNameString: 49 instructions
cng!__CfgFind: 252 instructions
cng!__security_check_cookie: 6 instructions
cng!memmove: 61 instructions
cng!memset: 59 instructions
ntkrnlmp!??_C@_1DO@NJNPPJHL@?$AAK?$AAe?$AAr?$AAn?$AAe?$AAl?$AA?9?$AAM?$AAU?$AAI?$AA?9?$AAL?$AAa?$AAn?$AAg@FNODOBFM@: 61 instructions
ntkrnlmp!CcSaveNVContext2: 39 instructions
ntkrnlmp!CmCallbackGetKeyObjectIDEx: 74 instructions
ntkrnlmp!CmCallbackReleaseKeyObjectIDEx: 5 instructions
ntkrnlmp!CmObReferenceObjectByHandle: 39 instructions
ntkrnlmp!CmOpenKey: 118 instructions
ntkrnlmp!CmPostCallbackNotificationEx: 50 instructions
ntkrnlmp!CmRmIsKCBVisible: 8 instructions
ntkrnlmp!CmSetValueKey: 294 instructions
ntkrnlmp!CmpAcquireShutdownRundown: 12 instructions
ntkrnlmp!CmpAddValueKeyNew: 70 instructions
ntkrnlmp!CmpAddValueToList: 7 instructions
ntkrnlmp!CmpAddValueToListEx: 55 instructions
ntkrnlmp!CmpAllocateKeyControlBlock: 28 instructions
ntkrnlmp!CmpAllocateTransientPoolWithTag: 4 instructions
ntkrnlmp!CmpArmLazyWriter: 63 instructions
ntkrnlmp!CmpAttachToRegistryProcess: 9 instructions
ntkrnlmp!CmpCallCallBacksEx: 239 instructions
ntkrnlmp!CmpCallbackFillObjectContext: 59 instructions
ntkrnlmp!CmpCheckOpenAccessOnKeyBody: 198 instructions
ntkrnlmp!CmpCleanUpKcbCachedSymlink: 11 instructions
ntkrnlmp!CmpCleanupKcbStack: 6 instructions
ntkrnlmp!CmpCleanupParseContext: 23 instructions
ntkrnlmp!CmpCleanupPathInfo: 6 instructions
ntkrnlmp!CmpCloseKeyObject: 36 instructions
ntkrnlmp!CmpCompareCompressedName: 52 instructions
ntkrnlmp!CmpCompareNewValueDataAgainstKCBCache: 44 instructions
ntkrnlmp!CmpComputeComponentHashes: 153 instructions
ntkrnlmp!CmpConstructNameFromKeyNodes: 144 instructions
ntkrnlmp!CmpConstructNameWithStatus: 74 instructions
ntkrnlmp!CmpCopyName: 26 instructions
ntkrnlmp!CmpCreateKeyBody: 148 instructions
ntkrnlmp!CmpCreateKeyControlBlock: 239 instructions
ntkrnlmp!CmpDelayedDerefKeys: 11 instructions
ntkrnlmp!CmpDereferenceKeyControlBlock: 193 instructions
ntkrnlmp!CmpDereferenceKeyControlBlockUnsafe: 7 instructions
ntkrnlmp!CmpDetachFromRegistryProcess: 5 instructions
ntkrnlmp!CmpDoCompareKeyName: 59 instructions
ntkrnlmp!CmpDoParseKey: 670 instructions
ntkrnlmp!CmpDoWritethroughReparse: 46 instructions
ntkrnlmp!CmpDoesBufferRequireCapturing: 13 instructions
ntkrnlmp!CmpDoesParseEnterRegistryA: 15 instructions
ntkrnlmp!CmpDrainDelayDerefContext: 11 instructions
ntkrnlmp!CmpFindKcbInHashEntryByName: 45 instructions
ntkrnlmp!CmpFindNameInListCellWithStatus: 95 instructions
ntkrnlmp!CmpFindNameInListWithStatus: 49 instructions
ntkrnlmp!CmpFindSecurityCellCacheIndex: 63 instructions
ntkrnlmp!CmpFree: 11 instructions
ntkrnlmp!CmpFreeTransientPoolWithTag: 4 instructions
ntkrnlmp!CmpGetCallbackObjectContext: 19 instructions
ntkrnlmp!CmpGetComponentHashAtIndex: 5 instructions
ntkrnlmp!CmpGetComponentNameAtIndex: 7 instructions
ntkrnlmp!CmpGetKcbAtLayerHeight: 5 instructions
ntkrnlmp!CmpGetNameControlBlock: 156 instructions
ntkrnlmp!CmpGetRegistryNamespaceRootForSilo: 17 instructions
ntkrnlmp!CmpGetSymbolicLinkTarget: 206 instructions
ntkrnlmp!CmpInitializeDelayDerefContext: 3 instructions
ntkrnlmp!CmpIsBufferGloballyVisible: 10 instructions
ntkrnlmp!CmpIsHiveLoadingOnOtherThread: 5 instructions
ntkrnlmp!CmpIsKeyDeleted: 30 instructions
ntkrnlmp!CmpIsKeyDeletedForKeyBody: 12 instructions
ntkrnlmp!CmpIsKeyStackDeleted: 20 instructions
ntkrnlmp!CmpIsKeyStackSymlink: 14 instructions
ntkrnlmp!CmpKeyFullNameLength: 24 instructions
ntkrnlmp!CmpKeyNodeNeedsAccessBitUpdate: 7 instructions
ntkrnlmp!CmpLockKcbShared: 10 instructions
ntkrnlmp!CmpLockKcbStackShared: 24 instructions
ntkrnlmp!CmpLockNameHashEntryExclusive: 16 instructions
ntkrnlmp!CmpLockRegistry: 13 instructions
ntkrnlmp!CmpLogDirtyVectorUse: 26 instructions
ntkrnlmp!CmpNameSize: 15 instructions
ntkrnlmp!CmpOKToFollowLink: 15 instructions
ntkrnlmp!CmpParseKey: 229 instructions
ntkrnlmp!CmpPerformCompleteKcbCacheLookup: 86 instructions
ntkrnlmp!CmpPerformSingleKcbCacheLookup: 275 instructions
ntkrnlmp!CmpPopulateKcbStack: 9 instructions
ntkrnlmp!CmpRecordParseFailure: 10 instructions
ntkrnlmp!CmpReferenceKeyControlBlockUnsafe: 9 instructions
ntkrnlmp!CmpReleaseGlobalQuota: 8 instructions
ntkrnlmp!CmpReleaseShutdownRundown: 7 instructions
ntkrnlmp!CmpReportNotifyForKcbStack: 34 instructions
ntkrnlmp!CmpReportNotifyHelper: 102 instructions
ntkrnlmp!CmpSetValueDataNew: 55 instructions
ntkrnlmp!CmpSetValueKeyNew: 46 instructions
ntkrnlmp!CmpStartKcbStack: 21 instructions
ntkrnlmp!CmpStartKcbStackForTopLayerKcb: 30 instructions
ntkrnlmp!CmpTransSilentIgnore: 4 instructions
ntkrnlmp!CmpTryConvertKcbLockSharedToExclusive: 8 instructions
ntkrnlmp!CmpUnlockHashEntryByKcb: 44 instructions
ntkrnlmp!CmpUnlockKcb: 21 instructions
ntkrnlmp!CmpUnlockKcbStack: 39 instructions
ntkrnlmp!CmpUnlockNameHashEntry: 16 instructions
ntkrnlmp!CmpUnlockRegistry: 11 instructions
ntkrnlmp!CmpUpdateKeyNodeAccessBits: 21 instructions
ntkrnlmp!CmpVEExecuteOpenLogic: 47 instructions
ntkrnlmp!CmpVEExecuteParseLogic: 50 instructions
ntkrnlmp!CmpValidateComponents: 17 instructions
ntkrnlmp!CmpWalkOneLevel: 405 instructions
ntkrnlmp!ExAcquirePushLockExclusiveEx: 65 instructions
ntkrnlmp!ExAcquirePushLockSharedEx: 67 instructions
ntkrnlmp!ExAcquireResourceExclusiveLite: 65 instructions
ntkrnlmp!ExAcquireResourceSharedLite: 24 instructions
ntkrnlmp!ExAcquireRundownProtection: 10 instructions
ntkrnlmp!ExAcquireSpinLockExclusive: 33 instructions
ntkrnlmp!ExAcquireSpinLockShared: 29 instructions
ntkrnlmp!ExAllocateHeapPool: 381 instructions
ntkrnlmp!ExAllocatePoolWithTag: 37 instructions
ntkrnlmp!ExFreeHeapPool: 209 instructions
ntkrnlmp!ExFreePoolWithTag: 4 instructions
ntkrnlmp!ExGenRandom: 66 instructions
ntkrnlmp!ExIsResourceAcquiredSharedLite: 26 instructions
ntkrnlmp!ExLockHandleTableEntry: 18 instructions
ntkrnlmp!ExProtectPoolEx: 94 instructions
ntkrnlmp!ExReleasePushLockEx: 120 instructions
ntkrnlmp!ExReleaseResourceLite: 59 instructions
ntkrnlmp!ExReleaseRundownProtection: 9 instructions
ntkrnlmp!ExReleaseSpinLockExclusiveFromDpcLevel: 10 instructions
ntkrnlmp!ExReleaseSpinLockSharedFromDpcLevel: 11 instructions
ntkrnlmp!ExSlowReplenishHandleTableEntry: 19 instructions
ntkrnlmp!ExpAcquireResourceSharedLite: 99 instructions
ntkrnlmp!ExpAcquireSpinLockExclusive: 26 instructions
ntkrnlmp!ExpAddTagForBigPages: 116 instructions
ntkrnlmp!ExpInterlockedPopEntrySListEnd: 7 instructions
ntkrnlmp!ExpInterlockedPopEntrySListFault: 3 instructions
ntkrnlmp!ExpInterlockedPopEntrySListResume: 5 instructions
ntkrnlmp!ExpLookupHandleTableEntry: 15 instructions
ntkrnlmp!ExpReleaseResourceSharedForThreadLite: 119 instructions
ntkrnlmp!ExpTryAcquireResourceExclusive: 8 instructions
ntkrnlmp!HalPutDmaAdapter: 5 instructions
ntkrnlmp!HalRequestSoftwareInterrupt: 58 instructions
ntkrnlmp!HalpApicRequestInterrupt: 55 instructions
ntkrnlmp!HvAllocateCell: 16 instructions
ntkrnlmp!HvFreeCell: 73 instructions
ntkrnlmp!HvLockHiveFlusherShared: 6 instructions
ntkrnlmp!HvMarkCellDirty: 5 instructions
ntkrnlmp!HvReallocateCell: 94 instructions
ntkrnlmp!HvUnlockHiveFlusherShared: 12 instructions
ntkrnlmp!HvlWriteApicCommandRegister: 10 instructions
ntkrnlmp!HvpAddBin: 112 instructions
ntkrnlmp!HvpAddFreeCellHint: 41 instructions
ntkrnlmp!HvpDoAllocateCell: 144 instructions
ntkrnlmp!HvpEnlistFreeCell: 51 instructions
ntkrnlmp!HvpFindFreeCell: 91 instructions
ntkrnlmp!HvpFindFreeCellInBin: 51 instructions
ntkrnlmp!HvpGetCellMap: 20 instructions
ntkrnlmp!HvpGetCellPaged: 45 instructions
ntkrnlmp!HvpIsFreeNeighbor: 33 instructions
ntkrnlmp!HvpMapEntryGetFreeBin: 6 instructions
ntkrnlmp!HvpMarkCellDirty: 75 instructions
ntkrnlmp!HvpMarkDirty: 120 instructions
ntkrnlmp!HvpReleaseCellPaged: 30 instructions
ntkrnlmp!HvpSetRangeProtection: 64 instructions
ntkrnlmp!IoThreadToProcess: 2 instructions
ntkrnlmp!KeAbPostRelease: 104 instructions
ntkrnlmp!KeAbPreAcquire: 63 instructions
ntkrnlmp!KeAcquireInStackQueuedSpinLock: 28 instructions
ntkrnlmp!KeAcquireSpinLockRaiseToDpc: 25 instructions
ntkrnlmp!KeAreInterruptsEnabled: 6 instructions
ntkrnlmp!KeBugCheckEx: 1 instructions
ntkrnlmp!KeEnterCriticalRegion: 3 instructions
ntkrnlmp!KeFlushMultipleRangeTb: 77 instructions
ntkrnlmp!KeGetCurrentStackPointer: 2 instructions
ntkrnlmp!KeInvalidAccessAllowed: 29 instructions
ntkrnlmp!KeLeaveCriticalRegion: 6 instructions
ntkrnlmp!KeLeaveCriticalRegionThread: 5 instructions
ntkrnlmp!KeQueryCurrentStackInformationEx: 102 instructions
ntkrnlmp!KeReleaseInStackQueuedSpinLockFromDpcLevel: 23 instructions
ntkrnlmp!KiAbThreadRemoveBoosts: 15 instructions
ntkrnlmp!KiBugCheckDispatch: 21 instructions
ntkrnlmp!KiDecrementProcessStackCount: 20 instructions
ntkrnlmp!KiFlushRangeWorker: 59 instructions
ntkrnlmp!KiInsertQueueDpc: 152 instructions
ntkrnlmp!KiIsTraceMemoryAccess: 4 instructions
ntkrnlmp!KiLeaveGuardedRegionUnsafe: 8 instructions
ntkrnlmp!KiMoveApcState: 24 instructions
ntkrnlmp!KiPageFault: 67 instructions
ntkrnlmp!KiPageFaultShadow: 4 instructions
ntkrnlmp!KiPreprocessFlushTb: 22 instructions
ntkrnlmp!KiReleaseThreadLockSafe: 8 instructions
ntkrnlmp!KiRspInIstStack: 25 instructions
ntkrnlmp!KiServiceInternal: 17 instructions
ntkrnlmp!KiSetAddressPolicy: 12 instructions
ntkrnlmp!KiStackAttachProcess: 140 instructions
ntkrnlmp!KiSwapProcess: 35 instructions
ntkrnlmp!KiSystemServiceCopyEnd: 8 instructions
ntkrnlmp!KiSystemServiceCopyStart: 4 instructions
ntkrnlmp!KiSystemServiceExit: 16 instructions
ntkrnlmp!KiSystemServiceGdiTebAccess: 12 instructions
ntkrnlmp!KiSystemServiceRepeat: 13 instructions
ntkrnlmp!KiSystemServiceStart: 5 instructions
ntkrnlmp!KiUnstackDetachProcess: 89 instructions
ntkrnlmp!KxAcquireSpinLock: 16 instructions
ntkrnlmp!KxReleaseSpinLock: 10 instructions
ntkrnlmp!KxSetAddressPolicy: 7 instructions
ntkrnlmp!MI_PFN_IS_PROTO: 4 instructions
ntkrnlmp!MI_READ_PTE_LOCK_FREE: 8 instructions
ntkrnlmp!MiCaptureDirtyBitToPfn: 10 instructions
ntkrnlmp!MiChargeCommit: 41 instructions
ntkrnlmp!MiCheckProcessShadow: 20 instructions
ntkrnlmp!MiCommitPoolMemory: 69 instructions
ntkrnlmp!MiCountSystemPool: 17 instructions
ntkrnlmp!MiDeterminePoolType: 16 instructions
ntkrnlmp!MiFastLockLeafPageTable: 79 instructions
ntkrnlmp!MiFillPoolCommitPageTable: 82 instructions
ntkrnlmp!MiFillPteHierarchy: 23 instructions
ntkrnlmp!MiFlushTbAsNeeded: 82 instructions
ntkrnlmp!MiFlushTbList: 34 instructions
ntkrnlmp!MiGenerateAccessViolation: 55 instructions
ntkrnlmp!MiGetAnyMultiplexedVm: 8 instructions
ntkrnlmp!MiGetSystemRegionType: 9 instructions
ntkrnlmp!MiInitializePoolCommitPacket: 76 instructions
ntkrnlmp!MiInsertTbFlushEntry: 106 instructions
ntkrnlmp!MiLinkPoolCommitChain: 77 instructions
ntkrnlmp!MiLockPageTableInternal: 62 instructions
ntkrnlmp!MiLockPoolCommitPageTable: 58 instructions
ntkrnlmp!MiLockPoolCommitWs: 13 instructions
ntkrnlmp!MiLockWorkingSetShared: 37 instructions
ntkrnlmp!MiMakeProtectionMask: 15 instructions
ntkrnlmp!MiMakeValidPte: 105 instructions
ntkrnlmp!MiPteInShadowRange: 5 instructions
ntkrnlmp!MiRaisedIrqlFault: 33 instructions
ntkrnlmp!MiReturnExcessPoolCommit: 13 instructions
ntkrnlmp!MiSwizzleInvalidPte: 10 instructions
ntkrnlmp!MiTransientCombineAddress: 20 instructions
ntkrnlmp!MiUnlockPageTableInternal: 32 instructions
ntkrnlmp!MiUnlockPoolCommitWs: 20 instructions
ntkrnlmp!MiUnlockWorkingSetShared: 43 instructions
ntkrnlmp!MmAccessFault: 84 instructions
ntkrnlmp!MmAllocatePoolMemory: 70 instructions
ntkrnlmp!MmIsSessionAddress: 12 instructions
ntkrnlmp!MmProtectPool: 213 instructions
ntkrnlmp!NLS_UPCASE: 4 instructions
ntkrnlmp!NtClose: 62 instructions
ntkrnlmp!NtOpenKey: 6 instructions
ntkrnlmp!NtSetValueKey: 235 instructions
ntkrnlmp!ObCloseHandleTableEntry: 193 instructions
ntkrnlmp!ObFastDereferenceObject: 13 instructions
ntkrnlmp!ObFastReferenceObject: 22 instructions
ntkrnlmp!ObGetCurrentIrql: 7 instructions
ntkrnlmp!ObOpenObjectByName: 28 instructions
ntkrnlmp!ObOpenObjectByNameEx: 249 instructions
ntkrnlmp!ObReferenceObjectByHandle: 10 instructions
ntkrnlmp!ObfDereferenceObjectWithTag: 34 instructions
ntkrnlmp!ObfReferenceObject: 18 instructions
ntkrnlmp!ObpAllocateObject: 183 instructions
ntkrnlmp!ObpCaptureObjectCreateInformation: 71 instructions
ntkrnlmp!ObpCaptureObjectName: 99 instructions
ntkrnlmp!ObpCreateHandle: 372 instructions
ntkrnlmp!ObpDeferObjectDeletion: 14 instructions
ntkrnlmp!ObpIncrementHandleCountEx: 136 instructions
ntkrnlmp!ObpIsKernelHandle: 10 instructions
ntkrnlmp!ObpLookupObjectName: 553 instructions
ntkrnlmp!ObpReferenceObjectByHandleWithTag: 167 instructions
ntkrnlmp!PsAttachSiloToCurrentThread: 4 instructions
ntkrnlmp!PsBoostThreadIo: 6 instructions
ntkrnlmp!PsBoostThreadIoEx: 56 instructions
ntkrnlmp!PsDetachSiloFromCurrentThread: 3 instructions
ntkrnlmp!PsGetCurrentProcess: 3 instructions
ntkrnlmp!PsGetCurrentSilo: 9 instructions
ntkrnlmp!PsGetCurrentThreadProcessId: 3 instructions
ntkrnlmp!PsGetPermanentSiloContext: 19 instructions
ntkrnlmp!PsGetProcessCreateTimeQuadPart: 2 instructions
ntkrnlmp!PsGetProcessId: 2 instructions
ntkrnlmp!PsGetProcessServerSilo: 2 instructions
ntkrnlmp!PsIsCurrentThreadInServerSilo: 11 instructions
ntkrnlmp!RtlAnsiCharToUnicodeChar: 57 instructions
ntkrnlmp!RtlAppendUnicodeToString: 51 instructions
ntkrnlmp!RtlCaptureStackBackTrace: 33 instructions
ntkrnlmp!RtlFindSetBits: 94 instructions
ntkrnlmp!RtlInitUnicodeString: 17 instructions
ntkrnlmp!RtlInitUnicodeStringEx: 17 instructions
ntkrnlmp!RtlNtStatusToDosErrorNoTeb: 44 instructions
ntkrnlmp!RtlPrefixUnicodeString: 35 instructions
ntkrnlmp!RtlRbInsertNodeEx: 128 instructions
ntkrnlmp!RtlRbRemoveNode: 236 instructions
ntkrnlmp!RtlSetBits: 46 instructions
ntkrnlmp!RtlUnicodeStringCat: 89 instructions
ntkrnlmp!RtlUnicodeStringCopy: 73 instructions
ntkrnlmp!RtlWalkFrameChain: 60 instructions
ntkrnlmp!RtlpCaptureContext2: 5 instructions
ntkrnlmp!RtlpGetStackLimits: 17 instructions
ntkrnlmp!RtlpHpAcquireLockExclusive: 12 instructions
ntkrnlmp!RtlpHpAcquireQueuedLockExclusive: 25 instructions
ntkrnlmp!RtlpHpAllocVA: 74 instructions
ntkrnlmp!RtlpHpEnvAllocVA: 72 instructions
ntkrnlmp!RtlpHpHeapCheckCommitLimit: 18 instructions
ntkrnlmp!RtlpHpLfhBucketAddSubsegment: 53 instructions
ntkrnlmp!RtlpHpLfhBucketGetSubsegment: 121 instructions
ntkrnlmp!RtlpHpLfhOwnerMoveSubsegment: 68 instructions
ntkrnlmp!RtlpHpLfhSlotAddSubsegment: 16 instructions
ntkrnlmp!RtlpHpLfhSlotAllocate: 676 instructions
ntkrnlmp!RtlpHpLfhSubsegmentFreeBlock: 347 instructions
ntkrnlmp!RtlpHpLfhSubsegmentIncBlockCounts: 175 instructions
ntkrnlmp!RtlpHpLfhSubsegmentSetOwner: 7 instructions
ntkrnlmp!RtlpHpReleaseQueuedLockExclusive: 29 instructions
ntkrnlmp!RtlpHpSegHeapCheckCommitLimit: 10 instructions
ntkrnlmp!RtlpHpSegLfhVsCommit: 62 instructions
ntkrnlmp!RtlpHpSegMgrCommit: 82 instructions
ntkrnlmp!RtlpHpSegPageRangeCommit: 179 instructions
ntkrnlmp!RtlpHpSegPageRangeHandleCommit: 81 instructions
ntkrnlmp!RtlpHpVsChunkSplit: 521 instructions
ntkrnlmp!RtlpHpVsContextAllocateInternal: 174 instructions
ntkrnlmp!RtlpInterlockedPopEntrySList: 3 instructions
ntkrnlmp!RtlpInterlockedPushEntrySList: 16 instructions
ntkrnlmp!RtlpIsUtf8Process: 22 instructions
ntkrnlmp!RtlpLfhBlockBitmapAllocate: 85 instructions
ntkrnlmp!RtlpLfhIncrementDataSlot: 36 instructions
ntkrnlmp!RtlpLookupFunctionEntryForStackWalks: 89 instructions
ntkrnlmp!RtlpUnwindPrologue: 182 instructions
ntkrnlmp!RtlpWalkFrameChain: 266 instructions
ntkrnlmp!RtlpxVirtualUnwind: 90 instructions
ntkrnlmp!SeAccessCheck: 21 instructions
ntkrnlmp!SeAccessCheckWithHint: 19 instructions
ntkrnlmp!SeAccessCheckWithHintWithAdminlessChecks: 317 instructions
ntkrnlmp!SeAuditHeaderRequired: 4 instructions
ntkrnlmp!SeClearLearningModeObjectInformation: 12 instructions
ntkrnlmp!SeComputeCreatorDeniedRights: 27 instructions
ntkrnlmp!SeLockSubjectContext: 14 instructions
ntkrnlmp!SeOpenObjectAuditAlarmWithTransaction: 116 instructions
ntkrnlmp!SeSetLearningModeObjectInformation: 10 instructions
ntkrnlmp!SeUnlockSubjectContext: 13 instructions
ntkrnlmp!SepAccessCheck: 180 instructions
ntkrnlmp!SepCreateAccessStateFromSubjectContext: 65 instructions
ntkrnlmp!SepDeleteAccessState: 25 instructions
ntkrnlmp!SepFilterCheck: 75 instructions
ntkrnlmp!SepMandatoryIntegrityCheck: 179 instructions
ntkrnlmp!SepNormalAccessCheck: 177 instructions
ntkrnlmp!VrpGetContextsForNotifyInfo: 37 instructions
ntkrnlmp!VrpRegistryCallback: 32 instructions
ntkrnlmp!VrpShouldOperateOnCall: 46 instructions
ntkrnlmp!ZwClose: 10 instructions
ntkrnlmp!ZwOpenKey: 10 instructions
ntkrnlmp!ZwSetValueKey: 10 instructions
ntkrnlmp!__security_check_cookie: 6 instructions
ntkrnlmp!_alloca_probe: 19 instructions
ntkrnlmp!_fputwc_nolock: 12 instructions
ntkrnlmp!_guard_dispatch_icall: 11 instructions
ntkrnlmp!_safecrt_mbtowc: 22 instructions
ntkrnlmp!_vsnwprintf: 6 instructions
ntkrnlmp!_vsnwprintf_l: 52 instructions
ntkrnlmp!_wcsnicmp: 31 instructions
ntkrnlmp!_woutput_l: 334 instructions
ntkrnlmp!ext_ms_win_ntos_tm_l1_1_0_TmIsKTMCommitCoordinator: 2 instructions
ntkrnlmp!memcmp: 49 instructions
ntkrnlmp!memmove: 85 instructions
ntkrnlmp!memset: 59 instructions
==> displaying instructions
instruction #0
cng!_ConfigurationFunctionIoHandler
fffff80483037f54 488bc4                          mov rax, rsp
instruction #1
cng!_ConfigurationFunctionIoHandler+0x3
fffff80483037f57 48895808                        mov [rax+0x08], rbx
instruction #2
cng!_ConfigurationFunctionIoHandler+0x7
fffff80483037f5b 48897010                        mov [rax+0x10], rsi
instruction #3
cng!_ConfigurationFunctionIoHandler+0xb
fffff80483037f5f 4c894820                        mov [rax+0x20], r9
instruction #4
cng!_ConfigurationFunctionIoHandler+0xf
fffff80483037f63 55                              push rbp
instruction #5
cng!_ConfigurationFunctionIoHandler+0x10
fffff80483037f64 57                              push rdi
instruction #6
cng!_ConfigurationFunctionIoHandler+0x11
fffff80483037f65 4156                            push r14
instruction #7
cng!_ConfigurationFunctionIoHandler+0x13
fffff80483037f67 488d68b1                        lea rbp, [rax-0x4f]
instruction #8
cng!_ConfigurationFunctionIoHandler+0x17
fffff80483037f6b 4881ecd0000000                  sub rsp, 0xd0
instruction #9
cng!_ConfigurationFunctionIoHandler+0x1e
fffff80483037f72 488b5d77                        mov rbx, [rbp+0x77]
```

```
instruction #2331910
ntkrnlmp!ExAllocateHeapPool+0x2f8
fffff804806caab8 0f57c0                          xorps xmm0, xmm0
instruction #2331911
ntkrnlmp!KiPageFaultShadow
fffff80480e11840 f644241001                      test byte ptr [rsp+0x10], 0x01
```

```
nt!ExAllocateHeapPool+0x2f8:
fffff804`806caab8 0f57c0          xorps   xmm0,xmm0
fffff804`806caabb 884702          mov     byte ptr [rdi+2],al
fffff804`806caabe 410fb6c4        movzx   eax,r12b
fffff804`806caac2 246d            and     al,6Dh
fffff804`806caac4 44895704        mov     dword ptr [rdi+4],r10d
fffff804`806caac8 0c02            or      al,2
fffff804`806caaca 448837          mov     byte ptr [rdi],r14b
fffff804`806caacd 0fb6d0          movzx   edx,al
```

Really symptomatic of snapshot limitation
A page needed by the allocator was not present in the snapshot (maybe on the swap)
I didn't investigate enough

bugcheck happen because memory pointed by rdi on 
```
fffff804`806caabb 884702          mov     byte ptr [rdi+2],al
```

is not present in the snapshot


kd> !pte ffff968739db4530
                                           VA ffff968739db4530
PXE at FFFFE070381C0968    PPE at FFFFE0703812D0E0    PDE at FFFFE07025A1CE70    PTE at FFFFE04B439CEDA0
contains 0A00000104ACC863  contains 0A00000104ACD863  contains 0A00000059FC5863  contains 0000000000000000
pfn 104acc    ---DA--KWEV  pfn 104acd    ---DA--KWEV  pfn 59fc5     ---DA--KWEV  not valid


instruction #2331910:
rax=0000000000000011 rbx=0000000000000000 rcx=0000000000000000
rdx=0000000000000000 rsi=0000000000000110 rdi=ffff968739db4530
rip=fffff804806caab8 rsp=ffff8704058ad440 rbp=ffff8704058ad521
 r8=ffff8704058ad300  r9=7fff968739d97018 r10=000000002079654b
r11=0000000000039d97 r12=0000000000000001 r13=ffff968731600000
r14=0000000000000000 r15=0000000000000110
rflags=40282
ntkrnlmp!ExAllocateHeapPool+0x2f8
fffff804806caab8 0f57c0 

rdi comes from the addition of ffff968739d97000 and 1d530

Clearly related to some LFH internals

kd> dt -v ntkrnlmp!_HEAP_LFH_SUBSEGMENT ffff968739d97000
struct _HEAP_LFH_SUBSEGMENT, 16 elements, 0x38 bytes
   +0x000 ListEntry        : struct _LIST_ENTRY, 2 elements, 0x10 bytes
 [ 0xffff9687`36965000 - 0xffff9687`36713000 ]
   +0x010 Owner            : 0xffff9687`31602000 struct _HEAP_LFH_SUBSEGMENT_OWNER, 10 elements, 0x38 bytes
   +0x010 DelayFree        : union _HEAP_LFH_SUBSEGMENT_DELAY_FREE, 3 elements, 0x8 bytes
   +0x018 CommitLock       : 0
   +0x020 FreeCount        : 0x21c
   +0x022 BlockCount       : 0x387
   +0x020 InterlockedShort : 0n540
   +0x020 InterlockedLong  : 0n59179548
   +0x024 FreeHint         : 0x16e
   +0x026 Location         : 0 ''
   +0x027 WitheldBlockCount : 0x3b ';'
   +0x028 BlockOffsets     : struct _HEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS, 3 elements, 0x4 bytes
   +0x02c CommitUnitShift  : 0xc ''
   +0x02d CommitUnitCount  : 0x40 '@'
   +0x02e CommitStateOffset : 0x128
   +0x030 BlockBitmap      : [1] 0x55555555`55555555



```
❯ rewind-cng trace run --backend bochs --snapshot .\snapshots\19041.1.amd64fre.vb_release.191206-1406\cng\_ConfigurationFunctionIoHandler\ --input .\input.json --data .\46473e281d56fad5.bin
:: Running tracer
==> loading snapshot
==> will use bochs backend
==> setting tracer initial state
rax=ffff8704058ae790 rbx=0000000000003aab rcx=0000000000010400
rdx=ffffaa0f0d4cb000 rsi=0000000000000008 rdi=0000000000003aab
rip=fffff80483037f54 rsp=ffff8704058ae6c8 rbp=0000000000000008
 r8=0000000000003aab  r9=ffffaa0f1f7ee000 r10=0000000000000000
r11=ffffaa0f0d4cb008 r12=ffffaa0f0d4cb000 r13=ffff8704058ae808
r14=ffffaa0f1f7ee000 r15=ffffaa0f1f8f1000
cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b  rflags=40246
==> replaying input ".\\46473e281d56fad5.bin"
==> writing input to ffffaa0f0d4cb000 (3aab)
==> running tracer
==> executed 309124 instruction(s) in 198.9743ms (Error("access outside known alloc at fffff804830924fb: write 2 bytes to ffffaa0f092fe6b2 (buffer allocated at fffff80483036e19 size 2)"))
==> seen 16049 unique address(es)
==> mapped 536 page(s) (2.2 MB)
==> 234 page(s) were modified
```


# 

in this part start fuzzing campaign
explain the mutator
explain the coverage
why we accept to lose some coverage precision
explain how we cycle with our corpus
explain how we leverage bochs to have some memory filtering and cmp instrumentation

show ida image to see that it's better to do a snapshot one function lower
redo snapshot
relaunch fuzzer

launch the monitor
launch a fuzzer with bochs
use edge coverage with bochs

show the differences in speed
explain why the speed decrease after a while
show coverage
coverage greatly increased but we start to see a lot of allocation and snapshot restore is slow

explain why whvp fuzzer encounters crashes not reproducible by bochs
show ida image

explain why after a while fuzzer is stopped

change mutation strategy
show msdn documentation
show dummy structured fuzzer

relaunch fuzzers
found the vuln

# 

in this part conclusion and next steps
the compromise is taking a toll
need better coverage
whvp is not adapted to do that
need to experiment with kvm
need to experiment with ipt
need to experiment with qbdi
explain the challenge

#

bonus part
explain how triton can be used
show script output
