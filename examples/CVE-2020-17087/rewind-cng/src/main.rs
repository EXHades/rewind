
use std::{collections::HashSet, error::Error};

use rewind_cli::{cli::Rewind, fuzz, mem, mutation, trace};

#[derive(Default)]
struct AllocatedBuffer {
    address: u64,
    size: u64,
    location: u64
}

struct ExAllocatePoolWithTag {
    address: u64,
    allocs: Vec<AllocatedBuffer>,
    return_addresses: HashSet<u64>,
}

impl ExAllocatePoolWithTag {

    fn new(address: u64) -> Self {
        Self {
            address,
            allocs: Vec::new(),
            return_addresses: HashSet::new(),
        }

    }

    fn dispatch<T: trace::Tracer + mem::X64VirtualAddressSpace>(&mut self, tracer: &mut T, address: u64) -> Result<bool, trace::TracerError> {
        if address == self.address {
            let state = tracer.get_state()?;
            let return_address = tracer.read_gva_u64(state.cr3, state.rsp)?;
            tracer.add_breakpoint(return_address);
            let allocated = AllocatedBuffer {
                location: return_address,
                size: state.rdx,
                ..Default::default()
            };
            self.allocs.push(allocated);
            self.return_addresses.insert(return_address);
            return Ok(true)
        }
        
        if self.return_addresses.contains(&address) {
            let state = tracer.get_state()?;
            if let Some(allocated) = self.allocs.last_mut() {
                allocated.address = state.rax;
                // need to walk stack trace
                // println!("ExAllocatePoolWithTag({:x}) = {:x}", allocated.size, allocated.address);
            };
            return Ok(true)

        }

        Ok(false)
    }

}

// struct CngSaveRoot {
//     address: u64,

// }

// impl CngSaveRoot {

//     fn new(address: u64) -> Self {
//         Self {
//             address
//         }
//     }

//     fn dispatch<T: trace::Tracer>(&mut self, tracer: &mut T, address: u64) -> Result<bool, trace::TracerError> {
//         if self.address == address {
//             // println!("in cng save root");
//             let mut state = tracer.get_state()?;
//             state.rax = 0;
//             state.rip += 5;
//             tracer.set_state(&state)?;
//             return Ok(true)
//         }
//         Ok(false)
//     }
// }

enum Breakpoint {
    ExAllocatePoolWithTag(ExAllocatePoolWithTag),
}

struct CngHook {
    breakpoints: Vec<Breakpoint>,
}

impl Default for CngHook {

    // FIXME: resolve address
    fn default() -> Self {

        // let cng_save_root_address: u64 = 0xfffff8048308fe2f;
        // let ex_allocate_pool_address: u64 = 0xfffff80480db1030;
        // let cfg_adtp_format_property_block: u64 = 0xfffff8048309245c;

        Self {
            breakpoints: Vec::new(),
        }

    }

}


impl trace::Hook for CngHook {

    fn setup<T: trace::Tracer + mem::X64VirtualAddressSpace>(&mut self, tracer: &mut T) {
        // let address: u64 = 0xfffff8048308fe2f;

        // let bp = CngSaveRoot::new(address);
        // self.breakpoints.push(Breakpoint::CngSaveRoot(bp));
        // tracer.add_breakpoint(address);

        // let address: u64 = 0xfffff80480db1030;
        // let address = 0xfffff80714fb1030;
        // FIXME: extract address from snapshot
        // let address = 0xfffff8051a3e9030;
        let address = 0xfffff8001694d030;
        let bp = ExAllocatePoolWithTag::new(address);
        self.breakpoints.push(Breakpoint::ExAllocatePoolWithTag(bp));
        tracer.add_breakpoint(address);
    }

    fn handle_breakpoint<T1: trace::Tracer + mem::X64VirtualAddressSpace>(&mut self, tracer: &mut T1) -> Result<bool, trace::TracerError>
    {
        let state = tracer.get_state()?;
        let address = state.rip;

        for bp in self.breakpoints.iter_mut() {
            match bp {
                Breakpoint::ExAllocatePoolWithTag(bp) => {
                     let handled = bp.dispatch(tracer, address)?;
                     if handled {
                         return Ok(true)
                     }
                },
            };
        }
        Ok(true)

    }

    fn handle_trace(&self, t: &mut trace::Trace) -> Result<bool, trace::TracerError> {
        for bp in self.breakpoints.iter() {
            let Breakpoint::ExAllocatePoolWithTag(bp) = bp;
            for access in t.mem_accesses.iter() {
                for alloc in bp.allocs.iter() {
                    // if access.vaddr >= alloc.address && access.vaddr < alloc.address + alloc.size {
                        // println!("{:x?} {:x?}", access, alloc);
                        // if access.1 + access.3 as u64 > alloc.address + alloc.size {
                            // println!("access outside known alloc");
                        // }
                    // }
                    if access.vaddr == alloc.address + alloc.size {
                        let msg = format!("access outside known alloc at {:x}: {:?} {:x} bytes to {:x} (buffer allocated at {:x} size {:x})", access.rip, access.access_type, access.size, access.vaddr, alloc.location, alloc.size);
                        t.status = trace::EmulationStatus::Error(msg);
                    }
                }
            }
        }

        Ok(true)
    }

    fn patch_page(&self, gva: u64) -> bool {
        let gva_base = 0xfffff80480689000;
        !(gva_base <= gva && gva < gva_base + 0x1000)
    }

}

#[derive(Default)]
struct Cli {

}

impl Rewind for Cli {

    type FuzzerHook = CngHook;
    type TraceHook = CngHook;
    type FuzzingStrategy = mutation::BasicStrategy;

    fn create_fuzzer_hook(&self) -> <Self as Rewind>::FuzzerHook {
        CngHook::default()
    }

    fn create_tracer_hook(&self) -> <Self as Rewind>::TraceHook {
        CngHook::default()
    }

    fn create_fuzzing_strategy(&self, _params: &fuzz::Params, mutator: mutation::Mutator) -> Self::FuzzingStrategy {
        mutation::BasicStrategy::new(mutator)
    }
    // FIXME: monitor hook ?
    // validator hook / replay hook ?
    // fuzzing strategy

}


fn main() -> Result<(), Box<dyn Error>> {

    color_eyre::install()?;

    // FIXME: resolve addresses ? how to go store and system ?
    // FIXME: need to have several hooks ?
    // Use associated type ?
    // tracer hook
    // fuzzer hook
    // mutation strategy
    // struct Cli
    // impl TraceHook for Cli
    // impl FuzzerHook for Cli
    let cli = Cli::default();

    cli.run()?;


    Ok(())
}
